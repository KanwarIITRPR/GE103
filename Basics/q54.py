list_to_be_searched = [1, 4, 7, 3, 0, 9] # Defining the list that has to be searched in
list_to_be_searched.sort() # Sorting the list so as to perform Binary Search

def binary_search(l, element, continuation_index = 0): # Giving the list to be searched, element that is to be searched and the index we are at
    mid_index = int(len(l)//2) # Defines the middle value so as to dissect the list and discard one half

    if element not in l: # Checking if the user has entered a wrong element to check for (coincidently acts as an internal check if the list we are recursing is the right one)
        return None

    # Checking if the element is the required number or it is present in which half
    if element == l[mid_index]:
        return continuation_index + mid_index # Retuens the net index
    elif element > l[mid_index]: # If element to be searched for is in the next half
        # Recursing the function with the 2nd list, generated by halving, to keep checking until element is reached
        # Continuation index is increased by the middle index + 1 as when we move in the next half, the index will be the one more than the length of the 1st half
        return binary_search(l[mid_index + 1:], element, continuation_index + mid_index + 1) 
    else: # If the elemebnt is in the previous half
        # Recursing the function with the 1st list, generated by halving, to keep checking until element is reached
        # Continuation index is increased by 0, i.e., kept the same as when we move in the 1st half, the starting element of the list in previous case and in 1st half is same - thus no need to increase continuation index
        return binary_search(l[:mid_index], element, continuation_index + 0)
    
print(f"The original list is {list_to_be_searched}.")
element = int(input("Enter the element you want to search for: "))
print(f"The element that you entered is at {binary_search(list_to_be_searched, element)} index.")
    